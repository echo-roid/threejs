<!DOCTYPE html>
<html>
<head>
  <script src="https://unpkg.com/konva@9.3.11/konva.min.js"></script>
  <meta charset="utf-8" />
  <title>Polygon Drawing </title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #f0f0f0;
    }
    #draw-button {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 10px;
      background-color: #007bff;
      color: white;
      border: none;
      cursor: pointer;
      font-size: 16px;
      z-index: 22;
    }
    #finish-button {
      position: absolute;
      top: 10px;
      left: 100px;
      padding: 10px;
      background-color: #28a745;
      color: white;
      border: none;
      cursor: pointer;
      font-size: 16px;
      display: none;
      z-index: 22;
    }
  </style>
</head>
<body>
  <button id="draw-button">Draw Polygon</button>
  <button id="finish-button">Finish Drawing</button>
  <div id="container"></div>
  <script>
    var width = window.innerWidth;
    var height = window.innerHeight;

    var stage = new Konva.Stage({
      container: 'container',
      width: width,
      height: height,
    });

    var layer = new Konva.Layer();
    stage.add(layer);

    var drawing = false;
    var points = [];
    var polygon, tempLine, anchors = [];

    function buildAnchor(x, y) {
      var anchor = new Konva.Circle({
        x: x,
        y: y,
        radius: 10,
        stroke: '#666',
        fill: '#ddd',
        strokeWidth: 2,
        draggable: true,
      });
      layer.add(anchor);

      anchor.on('mouseover', function () {
        document.body.style.cursor = 'pointer';
        this.strokeWidth(4);
        layer.batchDraw();
      });
      anchor.on('mouseout', function () {
        document.body.style.cursor = 'default';
        this.strokeWidth(2);
        layer.batchDraw();
      });

      anchor.on('dragmove', function () {
        updatePolygon();
      });

      return anchor;
    }

    function updatePolygon() {
      var newPoints = [];
      for (var i = 0; i < anchors.length; i++) {
        newPoints.push(anchors[i].x());
        newPoints.push(anchors[i].y());
      }
      polygon.points(newPoints);
      layer.batchDraw();
    }

    document.getElementById('draw-button').addEventListener('click', function() {
      drawing = true;
      points = [];
      if (polygon) {
        polygon.destroy();
        anchors.forEach(anchor => anchor.destroy());
        anchors = [];
      }
      tempLine = new Konva.Line({
        stroke: 'black',
        strokeWidth: 2,
        points: [],
        dash: [10, 5],
      });
      layer.add(tempLine);
      layer.draw();
      document.getElementById('finish-button').style.display = 'block';
    });

    document.getElementById('finish-button').addEventListener('click', function() {
      drawing = false;
      if (tempLine) {
        tempLine.destroy();
      }
      drawFinalPolygon();
      document.getElementById('finish-button').style.display = 'none';
    });

    stage.on('mousedown', function(e) {
      if (!drawing) return;

      var pos = stage.getPointerPosition();
      var newPoints = points.concat([pos.x, pos.y]);

      if (!doesIntersect(newPoints)) {
        points.push(pos.x, pos.y);
        updateTempLine();

        if (points.length >= 4 && closeEnough(pos, {x: points[0], y: points[1]})) {
          points.pop(); // remove last point
          points.pop(); // remove last point
          drawing = false;
          if (tempLine) {
            tempLine.destroy();
          }
          drawFinalPolygon();
          document.getElementById('finish-button').style.display = 'none';
        }
      }
    });

    stage.on('mousemove', function(e) {
      if (!drawing) return;

      var pos = stage.getPointerPosition();
      if (tempLine) {
        var newPoints = points.concat([pos.x, pos.y]);
        tempLine.points(newPoints);
        layer.batchDraw();
      }
    });

    function updateTempLine() {
      if (tempLine) {
        tempLine.points(points);
        layer.batchDraw();
      }
    }

    function closeEnough(p1, p2) {
      var dx = p1.x - p2.x;
      var dy = p1.y - p2.y;
      return dx * dx + dy * dy < 100; // threshold for closing the polygon
    }

    function doesIntersect(newPoints) {
      if (newPoints.length < 6) return false; // Not enough points to intersect
      var lastLine = {
        x1: newPoints[newPoints.length - 4],
        y1: newPoints[newPoints.length - 3],
        x2: newPoints[newPoints.length - 2],
        y2: newPoints[newPoints.length - 1]
      };

      for (var i = 0; i < newPoints.length - 4; i += 2) {
        var line = {
          x1: newPoints[i],
          y1: newPoints[i + 1],
          x2: newPoints[i + 2],
          y2: newPoints[i + 3]
        };
        if (intersect(line, lastLine)) return true;
      }
      return false;
    }

    function intersect(line1, line2) {
      var det, gamma, lambda;
      det = (line1.x2 - line1.x1) * (line2.y2 - line2.y1) - (line2.x2 - line2.x1) * (line1.y2 - line1.y1);
      if (det === 0) {
        return false;
      } else {
        lambda = ((line2.y2 - line2.y1) * (line2.x2 - line1.x1) + (line2.x1 - line2.x2) * (line2.y2 - line1.y1)) / det;
        gamma = ((line1.y1 - line1.y2) * (line2.x2 - line1.x1) + (line1.x2 - line1.x1) * (line2.y2 - line1.y1)) / det;
        return (0 < lambda && lambda < 1) && (0 < gamma && gamma < 1);
      }
    }
    function updatePolygon() {
        var newPoints = [];
        for (var i = 0; i < anchors.length; i++) {
            newPoints.push(anchors[i].x());
            newPoints.push(anchors[i].y());
        }

        if (isValidPolygon(newPoints)) {
            polygon.points(newPoints);
            layer.batchDraw();
            return true;
        } else {
            return false;
        }
    }

    function isValidPolygon(points) {
        var numPoints = points.length;
        for (var i = 0; i < numPoints; i += 2) {
            for (var j = i + 4; j < numPoints; j += 2) {
                if (intersect(
                    { x1: points[i], y1: points[i + 1], x2: points[(i + 2) % numPoints], y2: points[(i + 3) % numPoints] },
                    { x1: points[j], y1: points[j + 1], x2: points[(j + 2) % numPoints], y2: points[(j + 3) % numPoints] }
                )) {
                    return false;
                }
            }
        }
        return true;
    }

    function intersect(line1, line2) {
        var det, gamma, lambda;
        det = (line1.x2 - line1.x1) * (line2.y2 - line2.y1) - (line2.x2 - line2.x1) * (line1.y2 - line1.y1);
        if (det === 0) {
            return false;
        } else {
            lambda = ((line2.y2 - line2.y1) * (line2.x2 - line1.x1) + (line2.x1 - line2.x2) * (line2.y2 - line1.y1)) / det;
            gamma = ((line1.y1 - line1.y2) * (line2.x2 - line1.x1) + (line1.x2 - line1.x1) * (line2.y2 - line1.y1)) / det;
            return (0 < lambda && lambda < 1) && (0 < gamma && gamma < 1);
        }
    }

    function drawFinalPolygon() {
      polygon = new Konva.Line({
        stroke: 'black',
        strokeWidth: 3,
        fill: 'rgba(0, 128, 0, 0.5)',
        closed: true,
        points: points,
      });
      layer.add(polygon);

      for (var i = 0; i < points.length; i += 2) {
        anchors.push(buildAnchor(points[i], points[i + 1]));
      }
      layer.draw();
    }
  </script>
</body>
</html>
